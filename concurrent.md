# 提升Java并发性

## CompletableFuture 及 反应式编程
Java20年并发性的演进主要反映在计算机硬件，软件系统以及编程概念的变化上：
+ Java一开始就提供了锁（synchronized 类和方法）、Runnable、线程
+ Java5 引入JUC（java.util.concurrent),特别是ExecutorService接口（提供线程池的概念，将“任务提交”和“任务执行”解耦），还有Callable和Future（封装成Runnable和Thread的变体）随着泛型的一起加入。
这些特性促进了多喝CPU上并行编程的发展。
+ Java7 引入fork/join 算法
+ Java8 增加流和对流的并行处理
+ Java9 支持分布式异步编程，反应式编程

线程以及更高层的抽象：
* 单CPU计算机可以支持多用户，操作系统给每个用户创建了一个进程，这些进程拥有独立的虚拟地址空间，操作系统通过唤醒的方式让多个进程贡献CPU资源
* 一个进程可以请求操作系统给他分配一个或多个线程，这些线程与主进程共享地址空间，因此可以并发的执行任务并相互协调。

执行器和线程池：  

Java5 提供了一个执行器框架，可以充分发挥线程的能力，使得程序员可以解耦任务的提交与执行。
1. 线程的问题  
    Java线程直接访问操作系统的线程，主要问题在于创建和删除操作系统的线程代价会很大（涉及到页表操作）。  
    
    操作系统中线程数量有限，如果创建的线程数超过操作系统的限制会导致应用莫名其妙奔溃
    
2. 线程池的优势  
    低成本执行多任务；保证安全性、可控性
    
3. 线程池的不足  
    线程池死锁，应该避免向线程池提交可能阻塞的任务（睡眠，等待其他事件）  
    
    确保退出程序之前关闭每一个线程池
    
## 同步异步API
Future风格得API：  
将同步API变为异步API，也就是说不需要方法在物理返回其调用者的同时返回它的执行结果，提前返回调用函数，这时可以并发执行。  

反应式风格API：  
也就是回调，当异步函数执行完成时，自动执行后续操作；更适合处理一系列的值，Future更适合作为一次性处理。  

有害的睡眠及其他阻塞操作：  


## CompletableFuture：组合式异步编程
### Future接口
它的设计初衷是对将来某个时刻会发生的结果进行建模，返回一个指向执行结果的引用。  
1. 比底层的Thread更好用
2. 将耗时的操作封装在Callable中，并将其提交给ExecutorService  

使用CompletableFuture构建异步应用：

